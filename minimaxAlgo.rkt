#lang racket
(require "utils.rkt")
(require "eval-func.rkt")
(provide (all-defined-out))
(define (mini-max state cP depth phase cnt alpha beta)
  (displayln "kabali da")
  (displayln alpha)
  (displayln beta)
  (define (func1 cP depth phase cnt bx alph bet)
    (cond [(= cP 1) (begin (define nw-state (make-3d-vector 3 3 3 0))
                           (vec-copy nw-state state)
                           (3vs nw-state bx 1)
                           (cond [(checkS nw-state bx 1) (begin (define ta alph) (define tb bet) (define temp (cons 0 0)) (let* ((aim2 (all-in-mill nw-state 2))
                                                                (p2b (filter (λ(x) (and (= (3vf nw-state x) 2)
                                                                               (or aim2 (not (checkS nw-state x 2))))) all-list))
                                                       (vls (map (λ(x) (if (<= tb ta) (cons -10000000 '()) (begin (3vs nw-state x 0)
                                                                              (set! temp (mini-max nw-state 2 (- depth 1) phase cnt ta tb))
                                                                              (set! ta (max ta (car temp)))
                                                                              (3vs nw-state x 2)
                                                                              (cons (car temp) (cons bx x))))) p2b)))
                                                  (apply max1 vls)))]
                                 [else (cons (car (mini-max nw-state 2 (- depth 1) phase cnt alph bet)) bx)]))]
          [(= cP 2) (begin (define nw-state (make-3d-vector 3 3 3 0))
                           (vec-copy nw-state state)
                           (3vs nw-state bx 2)
                           (cond [(checkS nw-state bx 2) (begin (define ta alph) (define tb bet) (define temp (cons 0 0)) (let* ((aim1 (all-in-mill nw-state 1))
                                                                (p2b (filter (λ(x) (and (= (3vf nw-state x) 1)
                                                                               (or aim1 (not (checkS nw-state x 1))))) all-list))
                                                       (vls (map (λ(x) (if (<= tb ta) (cons 10000000 '()) (begin (3vs nw-state x 0)
                                                                              (set! temp (mini-max nw-state 1 (- depth 1) (if (> cnt 9) 1 0) (+ 1 cnt) ta tb))
                                                                              (set! tb (min tb (car temp)))
                                                                              (3vs nw-state x 1)
                                                                              (cons (car temp) (cons bx x))))) p2b)))
                                                  (apply min1 vls)))]
                                 [else (cons (car (mini-max nw-state 1 (- depth 1) (if (> cnt 9) 1 0) (+ cnt 1) alph bet)) bx)]))]
          )
  )

  (define (func2 cP depth phase cnt move alph bet)
    (cond [(= cP 1) (begin (define nw-state (make-3d-vector 3 3 3 0))
                           (vec-copy nw-state state)
                           (3vs nw-state (car move) 0)
                           (3vs nw-state (cdr move) 1)
                           (cond [(checkS nw-state (cdr move) 1) (begin (define ta alph) (define tb bet) (define temp (cons 0 0)) (let* ((aim2 (all-in-mill nw-state 2))
                                                                        (p2b (filter (λ(x) (and (= (3vf nw-state x) 2)
                                                                               (or aim2 (not (checkS nw-state x 2))))) all-list))
                                                       (vls (map (λ(x) (if (<= tb ta) (cons -10000000 '()) (begin (3vs nw-state x 0)
                                                                              (set! temp (mini-max nw-state 2 (- depth 1) phase cnt ta tb))
                                                                              (set! ta (max ta (car temp)))
                                                                              (3vs nw-state x 2)
                                                                              (cons (car temp) (cons move x))))) p2b)))
                                                  (apply max1 vls)))]
                                 [else (cons (car (mini-max nw-state 2 (- depth 1) phase cnt alph bet)) move)]))]
          [(= cP 2) (begin (define nw-state (make-3d-vector 3 3 3 0))
                           (vec-copy nw-state state)
                           (3vs nw-state (car move) 0)
                           (3vs nw-state (cdr move) 2)
                           (cond [(checkS nw-state (cdr move) 2) (begin (define ta alph) (define tb bet) (define temp (cons 0 0)) (let* ((aim1 (all-in-mill nw-state 1))
                                                                        (p2b (filter (λ(x) (and (= (3vf nw-state x) 1)
                                                                               (or aim1 (not (checkS nw-state x 1))))) all-list))
                                                       (vls (map (λ(x) (if (<= tb ta) (cons 10000000 '()) (begin (3vs nw-state x 0)
                                                                              (set! temp (mini-max nw-state 1 (- depth 1) (if (> cnt 9) 1 0) (+ 1 cnt) ta tb))
                                                                              (set! tb (min tb (car temp)))
                                                                              (3vs nw-state x 1)
                                                                              (cons (car temp) (cons move x))))) p2b)))
                                                  (apply min1 vls)))]
                                 [else (cons (car (mini-max nw-state 1 (- depth 1) (if (> cnt 9) 1 0) (+ cnt 1) alph bet)) move)]))]
          )
    )
  
  (cond [(= depth 0) (let* ((v1 (- (eval-phase state 1 phase) (eval-phase state 2 phase)))
                            (v2 (displayln v1)))
                       (cons v1 '()))]
        [(= phase 0) (cond [(= cP 1) (begin (define ta alpha)
                                            (define tb beta)
                                            (define temp (cons 0 0))
                                            (let* ((moves (filter (lambda (x) (let ((clr (3vf state x))) (= clr 0))) allowed-bxs))
                                                   (vls (map (λ(x) (if (<= tb ta)
                                                                       (begin (displayln "returning") (displayln tb) (displayln ta) (cons -10000000 '()))
                                                                       (begin (set! temp (func1 cP depth phase cnt x ta tb))
                                                                              (set! ta (max ta (car temp)))
                                                                              temp))) moves)))
                                              (apply max1 vls)))]
                           [(= cP 2) (begin (define ta alpha)
                                            (define tb beta)
                                            (define temp (cons 0 0))
                                            (let* ((moves (filter (lambda (x) (let ((clr (3vf state x))) (= clr 0))) allowed-bxs))
                                                   (vls (map (λ(x) (if (<= tb ta)
                                                                       (begin (displayln "returning") (displayln tb) (displayln ta) (cons 10000000 '()))
                                                                       (begin (set! temp (func1 cP depth phase cnt x ta tb))
                                                                              (set! tb (min tb (car temp)))
                                                                              temp))) moves)))
                                              (apply min1 vls)))])]
        [(= phase 1) (cond [(= cP 1) (begin (define ta alpha)
                                            (define tb beta)
                                            (define temp (cons 0 0))
                                            (let* ((moves (filter (λ(x) (and (= 1 (3vf state (car x)))
                                                                      (= 0 (3vf state (cdr x))))) neigh-pairs))
                                            (vls (map (λ(x) (if (<= tb ta)
                                                                       (cons -10000000 '())
                                                                       (begin (set! temp (func2 cP depth phase cnt x ta tb))
                                                                              (set! ta (max ta (car temp)))
                                                                              temp))) moves)))
                                       (apply max1 vls)))]
                           [(= cP 2) (begin (define ta alpha)
                                            (define tb beta)
                                            (define temp (cons 0 0))
                                            (let* ((moves (filter (λ(x) (and (= 2 (3vf state (car x)))
                                                                      (= 0 (3vf state (cdr x))))) neigh-pairs))
                                            (vls (map (λ(x) (if (<= tb ta)
                                                                       (cons 10000000 '())
                                                                       (begin (set! temp (func2 cP depth phase cnt x ta tb))
                                                                              (set! tb (min tb (car temp)))
                                                                              temp))) moves)))
                                       (apply min1 vls)))])])
  )